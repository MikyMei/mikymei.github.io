#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include
<common>\n#include
  <packing>\n#include
    <dithering_pars_fragment>\n#include
      <color_pars_fragment>\n#include
        <uv_pars_fragment>\n#include
          <uv2_pars_fragment>\n#include
            <map_pars_fragment>\n#include
              <alphamap_pars_fragment>\n#include
                <aomap_pars_fragment>\n#include
                  <lightmap_pars_fragment>\n#include
                    <emissivemap_pars_fragment>\n#include
                      <envmap_common_pars_fragment>\n#include
                        <envmap_pars_fragment>\n#include
                          <cube_uv_reflection_fragment>\n#include
                            <fog_pars_fragment>\n#include
                              <bsdfs>\n#include
                                <lights_pars_begin>\n#include
                                  <lights_phong_pars_fragment>\n#include
                                    <shadowmap_pars_fragment>\n#include
                                      <bumpmap_pars_fragment>\n#include
                                        <normalmap_pars_fragment>\n#include
                                          <specularmap_pars_fragment>\n#include
                                            <logdepthbuf_pars_fragment>\n#include
                                              <clipping_planes_pars_fragment>\n\n float distanceTo(vec2 src, vec2 dst)
                                                {\n float dx = src.x - dst.x;\n float dy = src.y - dst.y;\n float dv =
                                                dx * dx + dy * dy;\n return sqrt(dv);\n }\n\n float lerp(float x, float
                                                y, float t) {\n return (1.0 - t) * x + t * y;\n }\n\n vec3
                                                getGradientColor(vec3 color1, vec3 color2, float index) {\n float r =
                                                lerp(color1.r, color2.r, index);\n float g = lerp(color1.g, color2.g,
                                                index);\n float b = lerp(color1.b, color2.b, index);\n return vec3(r, g,
                                                b);\n }\n\n varying vec4 vPositionMatrix;\n varying vec3 vPosition;\n\n
                                                uniform float time;\n // 扩散参数\n uniform float uRadius;\n uniform float
                                                uOpacity;\n // 初始动画参数\n uniform float uStartTime; \n\n uniform vec3
                                                uMin;\n uniform vec3 uMax;\n uniform vec3 uSize;\n uniform vec3 uFlow;\n
                                                uniform vec3 uColor;\n uniform vec3 uCenter;\n uniform vec3 uSwitch;\n
                                                uniform vec3 uTopColor;\n uniform vec3 uFlowColor;\n uniform vec3
                                                uDiffusion; \n uniform vec3 uDiffusionCenter;\n\n void main() {\n
                                                \n\t#include
                                                <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity
                                                  );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ),
                                                  vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance
                                                  = emissive;\n\t#include
                                                  <logdepthbuf_fragment>\n\t#include
                                                    <map_fragment>\n\t#include
                                                      <color_fragment>\n\t#include
                                                        <alphamap_fragment>\n\t#include
                                                          <alphatest_fragment>\n\t#include
                                                            <specularmap_fragment>\n\t#include
                                                              <normal_fragment_begin>\n\t#include
                                                                <normal_fragment_maps>\n\t#include
                                                                  <emissivemap_fragment>\n\t#include
                                                                    <lights_phong_fragment>\n\t#include
                                                                      <lights_fragment_begin>\n\t#include
                                                                        <lights_fragment_maps>\n\t#include
                                                                          <lights_fragment_end>\n\t#include
                                                                            <aomap_fragment>\n\tvec3 outgoingLight =
                                                                              reflectedLight.directDiffuse +
                                                                              reflectedLight.indirectDiffuse +
                                                                              reflectedLight.directSpecular +
                                                                              reflectedLight.indirectSpecular +
                                                                              totalEmissiveRadiance;\n\t#include
                                                                              <envmap_fragment>\n\t\n vec3 distColor =
                                                                                outgoingLight;\n float dstOpacity =
                                                                                diffuseColor.a;\n \n float indexMix =
                                                                                vPosition.z / (uSize.z * 0.9);\n
                                                                                distColor = mix(distColor, uTopColor,
                                                                                indexMix);\n \n // 开启扩散波\n vec2
                                                                                position2D = vec2(vPosition.x,
                                                                                vPosition.y);\n if (uDiffusion.x > 0.5)
                                                                                {\n // 扩散速度\n float dTime = mod(time *
                                                                                uDiffusion.z, uRadius * 2.0);\n //
                                                                                当前的离中心点距离\n float uLen =
                                                                                distanceTo(position2D, vec2(uCenter.x,
                                                                                uCenter.z));\n\n // 扩散范围\n if (uLen <
                                                                                dTime && uLen > dTime - uDiffusion.y)
                                                                                {\n // 颜色渐变\n float dIndex = sin((dTime
                                                                                - uLen) / uDiffusion.y * PI);\n
                                                                                distColor = mix(uColor, distColor, 1.0 -
                                                                                dIndex);\n }\n }\n\n // 流动效果\n if
                                                                                (uFlow.x > 0.5) {\n // 扩散速度\n float
                                                                                dTime = mod(time * uFlow.z, uSize.z); \n
                                                                                // 流动范围\n float topY = vPosition.z +
                                                                                uFlow.y;\n if (dTime > vPosition.z &&
                                                                                dTime < topY) {\n // 颜色渐变 \n float
                                                                                dIndex = sin((topY - dTime) / uFlow.y *
                                                                                PI);\n\n distColor = mix(distColor,
                                                                                uFlowColor, dIndex); \n }\n }\n \n\n
                                                                                gl_FragColor = vec4(distColor,
                                                                                dstOpacity * uStartTime);\n \n\t#include
                                                                                <tonemapping_fragment>\n\t#include
                                                                                  <encodings_fragment>\n\t#include
                                                                                    <fog_fragment>\n\t#include
                                                                                      <premultiplied_alpha_fragment>
                                                                                        \n\t#include
                                                                                        <dithering_fragment>\n}
