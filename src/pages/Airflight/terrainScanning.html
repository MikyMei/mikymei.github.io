<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>地形扫描效果</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body></body>
<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/ImprovedNoise.js"></script>
<script src="js/stats.min.js"></script>
<script src="js/dat.gui.min.js"></script>
<script>
  var camera, scene, renderer, stats, control, material;

  var sphere, terrain, target, box, depthScene, orthCamera;

  var worldWidth = 256,
    worldDepth = 256,
    worldHalfWidth = worldWidth / 2,
    worldHalfDepth = worldDepth / 2;

  var speed = 50;

  var clock = new THREE.Clock();

  init();
  animate();

  function init() {
    camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 150000);
    camera.position.set(10000, 10000, 10000);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x333333);

    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    box = new THREE.Box3(
      new THREE.Vector3(-4000, 0, -4000),
      new THREE.Vector3(4000, 5000, 4000)
    );

    const material = new THREE.LineBasicMaterial({
      color: 0x0000ff
    });


    const centera=new THREE.Vector3()
    const points = [];
    points.push( new THREE.Vector3(-4000, 0, -4000), );
    points.push( new THREE.Vector3(4000, 5000, 4000));
    points.push( box.getCenter(centera));

    const geometry = new THREE.BufferGeometry().setFromPoints( points );

    const line = new THREE.Line( geometry, material );
    scene.add( line );

    terrain = createTerrain();

    createDepth();

    var axesHelper = new THREE.AxesHelper(5000);
    scene.add(axesHelper);

    stats = new Stats();
    document.body.appendChild(stats.dom);

    control = new THREE.OrbitControls(camera, renderer.domElement);

    window.addEventListener("resize", onWindowResize, false);
  }

  //创建深度图
  function createDepth() {

    target = new THREE.WebGLRenderTarget(worldWidth, worldDepth);
    target.texture.format = THREE.RGBFormat;
    target.texture.minFilter = THREE.NearestFilter;
    target.texture.magFilter = THREE.NearestFilter;
    target.texture.generateMipmaps = false;

    orthCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 2);
    const center = new THREE.Vector3();
    box.getCenter(center);
    console.log(box.getCenter(center));

    orthCamera.left = box.min.x - center.x;
    orthCamera.right = box.max.x - center.x;
    orthCamera.top = box.max.z - center.z;
    orthCamera.bottom = box.min.z - center.z;
    orthCamera.near = .1;
    orthCamera.far = box.max.y - box.min.y;

    orthCamera.position.copy(center);
    orthCamera.position.y += box.max.y - center.y;
    orthCamera.lookAt(center);

    this.orthCamera.updateProjectionMatrix();

    depthScene = new THREE.Scene();
    depthScene.overrideMaterial = new THREE.ShaderMaterial({
      vertexShader: `
        varying float color;
        float decodeRGBA2Float(vec4 rgba)
        {
            return dot(rgba, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
        }
        vec4 encodeFloat2RGBA(float v)
        {
            vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
            enc = fract(enc);
            enc -= enc.yzww * vec4(1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);
            return enc;
        }
        void main() {
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          color = gl_Position.z / 2.0 + 0.5;
        }
      `,
      fragmentShader: `
        uniform float cameraNear;
        uniform float cameraFar;
        varying float color;

        vec4 encodeFloat2RGBA(float v)
        {
            vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
            enc = fract(enc);
            enc -= enc.yzww * vec4(1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);
            return enc;
        }
        void main() {
            gl_FragColor = encodeFloat2RGBA(1.0 - color);
        }
      `,
      uniforms: {
        cameraNear: {value: orthCamera.near},
        cameraFar: {value: orthCamera.far},
      },
    });

    renderer.setRenderTarget(target);
    depthScene.children = [terrain];
    renderer.render(depthScene, orthCamera);
    renderer.setRenderTarget(null);
  }

  //创建地形
  function createTerrain() {
    var data = generateHeight(worldWidth, worldDepth);

    var geometry = new THREE.PlaneBufferGeometry(
      8000,
      8000,
      worldWidth - 1,
      worldDepth - 1
    );
    geometry.rotateX(-Math.PI / 2);

    var vertices = geometry.attributes.position.array;

    for (var i = 0, j = 0, l = vertices.length; i < l; i++, j += 3) {
      vertices[j + 1] = data[i] * 20;
    }

    texture = new THREE.CanvasTexture(
      generateTexture(data, worldWidth, worldDepth)
    );
    texture.wrapS = THREE.ClampToEdgeWrapping;
    texture.wrapT = THREE.ClampToEdgeWrapping;

    material = new THREE.MeshBasicMaterial({map: texture, side: THREE.DoubleSide});

    material.onBeforeCompile = function (shader, renderer) {
      //声明用到的变量和常量
      const getFoot = `
            uniform mat4 cameraMatrix;
            varying float depth;
            varying vec2 depthUv;
            #include <common>
            `;


      //此处获取到绘制顶点的世界坐标，并生成当前的深度图的uv
      const begin_vertex = `
            #include <worldpos_vertex>
            vec4 cameraDepth = cameraMatrix * modelMatrix * vec4( transformed, 1.0 );
            depthUv = cameraDepth.xy/2.0 + 0.5;
            `;

      const depth_vary = `
            uniform float time;
            uniform sampler2D tDepth;
            uniform float opacity;
            varying float depth;
            varying vec2 depthUv;
            `;

      const depth_frag = `
            vec3 d = diffuse;
            float step = abs(time - depthUv.x);
              if(step < 0.02){
                d = d * (2.0 - step * 50.0);
              }
              vec4 diffuseColor = vec4( d, opacity );
            `
      shader.vertexShader = shader.vertexShader.replace(
        "#include <common>",
        getFoot
      );
      shader.vertexShader = shader.vertexShader.replace(
        "#include <worldpos_vertex>",
        begin_vertex
      );
      shader.fragmentShader = shader.fragmentShader.replace('uniform float opacity;', depth_vary)
      shader.fragmentShader = shader.fragmentShader.replace('vec4 diffuseColor = vec4( diffuse, opacity );', depth_frag)

      shader.uniforms.time = {
        value: 0
      }
      shader.uniforms.cameraMatrix = {
        value: new THREE.Matrix4()
      }
      shader.uniforms.tDepth = {
        value: target.texture
      }
      material.uniforms = shader.uniforms;
    };

    mesh = new THREE.Mesh(
      geometry,
      material
    );
    scene.add(mesh);

    return mesh;
  }

  //更新材质的常量
  function updateMaterial() {
    if (material.uniforms) {
      const value = new THREE.Matrix4().multiplyMatrices(
        orthCamera.projectionMatrix,
        orthCamera.matrixWorldInverse
      );
      // if(material.uniforms.cameraMatrix.value.elements.toString()===value.elements.toString()){
      //   console.log("不变");
      // }else{
      //   console.log("改变",value.elements, material.uniforms.cameraMatrix.value.elements);
      // }
      material.uniforms.cameraMatrix.value=value
    }

  }

  //获取地形高度
  function generateHeight(width, height) {
    var size = width * height,
      data = new Uint8Array(size),
      perlin = new THREE.ImprovedNoise(),
      quality = 1,
      z = Math.random() * 100;

    for (var j = 0; j < 4; j++) {
      for (var i = 0; i < size; i++) {
        var x = i % width,
          y = ~~(i / width);
        data[i] += Math.abs(
          perlin.noise(x / quality, y / quality, z) * quality * 1.75
        );
      }

      quality *= 5;
    }

    return data;
  }

  //生成地形贴图
  function generateTexture(data, width, height) {
    var canvas, canvasScaled, context, image, imageData, vector3, sun, shade;

    vector3 = new THREE.Vector3(0, 0, 0);

    sun = new THREE.Vector3(1, 1, 1);
    sun.normalize();

    canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;

    context = canvas.getContext("2d");
    context.fillStyle = "#000";
    context.fillRect(0, 0, width, height);

    image = context.getImageData(0, 0, canvas.width, canvas.height);
    imageData = image.data;

    for (var i = 0, j = 0, l = imageData.length; i < l; i += 4, j++) {
      vector3.x = data[j - 2] - data[j + 2];
      vector3.y = 2;
      vector3.z = data[j - width * 2] - data[j + width * 2];
      vector3.normalize();

      shade = vector3.dot(sun);

      imageData[i] = (96 + shade * 128) * (0.5 + data[j] * 0.007);
      imageData[i + 1] = (32 + shade * 96) * (0.5 + data[j] * 0.007);
      imageData[i + 2] = shade * 96 * (0.5 + data[j] * 0.007);
    }

    context.putImageData(image, 0, 0);

    // Scaled 4x

    canvasScaled = document.createElement("canvas");
    canvasScaled.width = width * 4;
    canvasScaled.height = height * 4;

    context = canvasScaled.getContext("2d");
    context.scale(4, 4);
    context.drawImage(canvas, 0, 0);

    image = context.getImageData(
      0,
      0,
      canvasScaled.width,
      canvasScaled.height
    );
    imageData = image.data;

    for (var i = 0, l = imageData.length; i < l; i += 4) {
      var v = ~~(Math.random() * 5);

      imageData[i] += v;
      imageData[i + 1] += v;
      imageData[i + 2] += v;
    }

    context.putImageData(image, 0, 0);

    return canvasScaled;
  }

  function onWindowResize() {
    windowHalfX = window.innerWidth / 2;
    windowHalfY = window.innerHeight / 2;

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  //
  function animate() {
    requestAnimationFrame(animate);

    render();
    stats.update();
  }

  function render() {
    time = clock.getElapsedTime() / 5 % 1;

    if (material.uniforms) {
      material.uniforms.time.value = time;
    }

    updateMaterial();

    renderer.render(scene, camera);
  }
</script>

</html>
